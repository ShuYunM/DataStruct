<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Document</title>
  </head>
  <body>
    <script src="../链表/04、字典.js"></script>
    <script src="../队列结构/01队列类的创建.js"></script>
    <script>
      function Graph() {
        // 属性：顶点(数组)/边(字典)
        this.vertexts = []; // 顶点
        this.edges = new Dictionay(); //边

        // 添加顶点
        Graph.prototype.addVertex = function (v) {
          this.vertexts.push(v);
          this.edges.set(v, []);
        };
        // 添加边
        Graph.prototype.addEdge = function (v1, v2) {
          this.edges.get(v1).push(v2);
          this.edges.get(v2).push(v1);
        };

        // 实现toString
        Graph.prototype.toString = function () {
          let resultString = "";
          for (let i = 0; i < this.vertexts.length; i++) {
            resultString += this.vertexts[i] + "——>";
            let vEdges = this.edges.get(this.vertexts[i]);
            for (let index = 0; index < vEdges.length; index++) {
              resultString += vEdges[index] + "";
            }
            resultString += "\n";
          }
          return resultString;
        };

        // 图的遍历(广度优先(BFS)找出和当前顶点连接的节点在从当前节点的第一个出发找到和其相连接的节点(这些节点入栈)(把当前节点退栈，开始第二个节点),树的层次遍历、深度优先(DFS)类似于树结构的先序遍历，从当前顶点出发，一路往下找)
        // 初始化颜色
        Graph.prototype.initializeColor = function () {
          let colors = [];
          for (let i = 0; i < this.vertexts.length; i++) {
            colors[this.vertexts[i]] = "white";
          }
          return colors;
        };

        // 广度优先搜索(BFS)
        // initV起点,handler处理方式(由自己定义)
        Graph.prototype.bfs = function (initV, handler) {
          // 1、初始化颜色
          let colors = this.initializeColor();

          // 2、创建队列
          let queue = new Queue();

          // 3、将顶点加入到队列中
          queue.push(initV);

          // 4、循环从队列中取出元素
          while (!queue.isEmpty()) {
            // 取出队列中第一个元素，当前顶点
            let v = queue.shift();
            // 找出当前顶点对应的所有连接点
            let vList = this.edges.get(v);

            // 将取出的顶点颜色改为读取过，防止下次还入队列中
            colors[v] = "gray";

            // 循环当前顶点，将其对应的所有连接点放入队列中
            for (let i = 0; i < vList.length; i++) {
              let e = vList[i];
              // 如果探测过就不许要加入到队列中了
              if (colors[e] === "white") {
                colors[e] = "gray";
                queue.push(e);
              }
            }
            handler(v);
            colors[v] = "black";
          }
        };
      }

      //测试
      let graph = new Graph();
      let myVer = ["A", "B", "C", "D", "E", "F", "G", "H", "I"];
      for (let index = 0; index < myVer.length; index++) {
        graph.addVertex(myVer[index]);
      }
      graph.initializeColor();

      //3.添加边
      graph.addEdge("A", "B");
      graph.addEdge("A", "C");
      graph.addEdge("A", "D");
      graph.addEdge("C", "D");
      graph.addEdge("C", "G");
      graph.addEdge("D", "G");
      graph.addEdge("D", "H");
      graph.addEdge("B", "E");
      graph.addEdge("B", "F");
      graph.addEdge("E", "I");

      console.log(graph);
      alert(graph);
      let res = "";
      graph.bfs(graph.vertexts[0], function (v) {
        res += v + " ";
      });

      alert(res);
    </script>
  </body>
</html>
